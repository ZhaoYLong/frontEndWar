- 1.网站的性能优化有哪些？
  - 1.1 浏览器缓存
  - 1.2 资源打包压缩
  - 1.3 图片资源优化（webP, svg, 雪碧图） [雪碧图介绍](https://blog.csdn.net/allenyhy/article/details/81484642)
  - 1.4 CND
  - 1.5 减少回流和重绘

- 2.什么是回流和重绘？
  - 回流：当渲染树中的部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程叫做回流
  - 重绘：当页面中的元素样式改变不影响它在文档流中的位置时（color、background-color等），浏览器会将新的样式赋予给元素并重新绘制它，这个过程叫做重绘

- 回流一定引起重绘，重绘不一定引起回流

- 3如何避免回流和重绘？
  - CSS：避免table布局、避免设置多层内联样式、避免使用css表达式、将动画效果应用到position属性为fixed或absolute元素上
  - JS：避免频繁操作样式、对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流


- 3.http
  
HTTP/1.0:每次请求都打开一个新的TCP连接，收到响应之后立即断开连接。

HTTP/1.1：

- 在请求头中新增了range头域，允许只请求资源的某一部分
- HTTP/1.1的请求头和响应头必须有HOST头域，用来区分同一物理主机的不用虚拟服务器
- 长连接，一个TCP连接可以发送多个HTTP请求，减少了建立和关闭连接的消耗和延迟
- 缺点：线头堵塞、基于文本协议、请求和响应头信息非常大，无法压缩，单向请求

HTTP/2.0:

- 采用二进制协议解析
- 压缩头部,减少了需要传输的头部大小，并且通讯的双方都保存一份头部，避免重复的头部传输，减少了传输的大小
- 多路复用，允许并发的发送多个HTTP请求，每个请求不需要等待其他请求或响应，避免了线头阻塞的问题。这样如果某个请求任务耗时严重，不会影响到其他连接正常的执行，极大提高了传输性能。
- 服务端推送，会把客户端需要的css/img伴随index.html一同推送到客户端，省去了客户端的重复请求，需要使用时直接从缓存中获取。
- 缺点：如果TCP连接中出现了丢包的现象，会导致整个TCP连接重传

HTTP/3.0:

- HTTP/1.1、HTTP/2.0的缺点都是因为底层协议TCP导致的，所以Google 基于 UDP 协议推出了一个的 QUIC 协议，并且使用在了 HTTP/3 上。
- HTTP/3.0有避免包堵塞、快速重启会话的优点


- HTTP的首部字段

- Connection：浏览器想要优先使用的连接类型
- Cache-control:控制缓存的行为
- Date：创建报文的时间
- Accept：能正确接收的媒体类型：application/json、text/plain
- Accept-charset:用户支持的字符集
- Authorization：客户端认证信息，一般存token信息
- Cookie：发送给服务器的Cookie信息
- Host：服务器的域名
- Location：重定向到某个URL
- Set-Cookie：需要存在客户端的信息


- 浏览器缓存

- 浏览器的缓存可以分为两大类：强缓存和协商缓存，浏览器在加载资源的时候，首先会判断是否命中强缓存，在验证是否命中协商缓存。浏览器的缓存存放在disk cache（磁盘缓存）、memory cache(内存缓存)中。

强缓存

- 先会查看header中的Expire和Cache-Control来判断是否满足条件
- 如果满足，就返回缓存的数据
- 如果不满足，就向服务器发送请求
- 服务器返回数据，将数据存入缓存
- Expire表示缓存的到期时间，过了这个时间，缓存就是失效，如果人为的修改客户端本地时间，就会导致缓存失效

Cache-control：max-age表示资源缓存的最大有效时间,Cache-Contral：max-age=600表示有效时间是600s。no-cache表示需要进行协商缓存；no-store表示禁止使用缓存。

Cache-control的优先级比Expire的优先级高

协商缓存

- 把资源标识If-Modified -Since或者Etage发送服务器，确认资源是否更新
- 如果资源未更新，服务器返回状态304，并且显示not modifed的字符串，告诉浏览器使用本地缓存
- 如果资源已经更新，返回新的数据并把数据存入缓存
  
If-Modified-Since

- 浏览器第一次请求资源的时候，服务器返回的header上会带有last-modified字段，表示资源最后修改的时间。当浏览器再次请求资源时，请求头会带有一个If-Modified-Since字段，这个值是第一次请求返回的last-modified的值，服务器收到请求之后，将If-modified-Since和当前的last-modified进行比较。如果相同则说明资源没有修改，返回304，直接使用缓存。

Etag

- Etag一般是由文件内容hash生成，也就是说它可以保证资源的唯一性，资源发送改变就会导致Etag发送改变。同样的，在浏览器第一次请求时，服务器会返回一个Etag标识。当浏览器再次请求时，会通过If-no-match字段将Etag发送服务器，然后服务器进行比较，如果相等，返回304表示资源未修改。Etag每次生成都需要进行读写操作，消耗较大。

- If-Modified-Since和Etag可以同时设置，服务器会优先校验Etag，如果Etag相等就回继续比对Last-Modified，最后才会决定是否返回304.

衍生问题1：用户行为对浏览器缓存的影响

- 打开网页，地址栏输入地址：先查找磁盘缓存中是否有匹配，如果有则使用，如果没有则发送网络请求。
- 普通刷新（F5）：因为标签页没有关闭，因此内存缓存是可用的，会被优先使用（如果匹配的话），其次才是磁盘缓存
- 强制刷新（ctrl+F5）:浏览器不使用缓存，因此发送的请求头均带有Cache-control:no-cache,我放弃直接返回200和最新内容。


- 跨域的问题？