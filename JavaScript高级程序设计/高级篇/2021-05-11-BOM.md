> 浏览器对象模型（BOM），提供了与网页无关的浏览器功能对象。

- H5规范中有一部分涵盖了BOM的主要部分，因为W3C希望将JS在浏览器中最基础的部分标准化。

### window对象
- BOM核心：window对象，表示浏览器的实例。
- window对象在浏览器中有2重身份，一个是ES中的Global对象，另一个就是浏览器窗口的JS接口。
- 网页中定义的所有对象、变量和函数都是以window作为其Global对象
- window对象的属性在全局作用域中有效，所以很多浏览器API及相关构造函数都以window对象属性的形式暴露出来。

#### Global作用域
- 因为window对象被复用为ES的Global对象，所以通过var声明的所有全局变量和函数都会变成window对象的属性和方法。
- 全局作用域中，this会指向window对象
- let，const定义的变量和函数不会添加给window对象。

```js
  // 报错，因为oldVal没有声明
  var newVal = oldVal;
  // 不会报错，newVal会被设置为undefined
  var newVal = window.oldValue
```

- JavaScript中有很多对象都暴露在全局作用域中，比如location和navigator

#### 窗口关系
- top对象始终指向最上层（最外层）窗口，浏览器窗口本身。
- parent对象则始终指向当前窗口的父窗口。
  - 如果当前窗口就是最上层窗口，则parent 等于 top（都等于window）
  - 最上层的window如果不是通过window.open()打开的，那么name属性就不会包含值
- self对象，它是终极window属性，始终会指向window。
  - self和window就是同一个对象。之所以还要暴露self就是为了和top、parent保持一致。
- top、parent、self都是window对象的属性，因此可以通过window.top、window.parent、window.self访问。
  - 把访问多个窗口的window对象串联起来。比如，window.parent.parent

#### 窗口位置与像素比
- window对象的位置可以通过不同的属性和方法来确定。
- screenLeft：窗口相对于屏幕左侧的位置，返回的单位都是CSS像素
- screenTop：窗口相对于屏幕顶部的位置，返回的单位都是CSS像素

- moveTo(x, y)【x，y为新位置的绝对坐标】、moveBy(x, y)【接收相对当前位置在两个方向上移动的像素数】来移动窗口。这两个方法都接受两个参数。

```js
window.moveTo(0, 0)

window.moveBy(0, 1000)

window.moveTo(200, 300)

window.moveBy(-50, 0)
```

- 依浏览器而定，以上方法可能会被部分或全部禁用.

- 像素比
  - CSS像素是WEB开发中使用的统一像素单位。
  - 单位背后的角度：`0.0213`度。
  - 这样定义像素大小是为了在不同设备上统一标准。
  - window.devicePixelRatio用于转换不同设备之间的像素比，实际上与每英寸像素数（DPI, dots per inch）是对应的。DPI表示单位像素密度，而window.devicePixelRatio表示物理像素与逻辑像素之间的缩放系数。

#### 窗口大小
- 在不同的浏览器中确定浏览器窗口大小没有想象中那么容易。
- 现代浏览器支持4个属性：
  - innerWidth：返回浏览器窗口中页面视口的宽度
  - innerHeight：返回浏览器窗口中页面视口的高度（不包含浏览器边框和工具栏）
  - outerWidth：返回浏览器窗口自身宽度
  - outerHeight：返回浏览器窗口自身高度
  - （不管是在最外层window上使用，还是在窗格`<frame>`中使用）

- document.documentElement.clientWith
- document.documentElement.clientHeight：返回页面视口的宽度和高度

- 浏览器窗口自身的精确尺寸不好确定，但可以确定页面视口的大小，比如：

```js
  let pageWidth = window.innerWidth,
      pageHeight = window.innerHeight;
  if (typeof pageWidth != 'number') {
    if (document.compatMode == "CSS1Compat") {
      pageWidth = document.documentElement.clientWidth;
      pageHeight = document.documentElement.clientHeight;
    } else {
      pageWidth = document.body.clientWidth;
      pageHeight = document.body.clientHeight;
    }
  }
```
  - 先将pageWidth和pageHeight的值分别设置为window.innerWidth和window. innerHeight。
  - 然后，检查pageWidth是不是一个数值：
    - 如果不是则通过document.compatMode来检查页面是否处于标准模式。
    - 如果是，则使用document.documentElement.clientWidth和document.documentElement.clientHeight；
    - 否则，就使用document.body.clientWidth和document.body.clientHeight

- 移动设备上，window.innerWidth和window.innerHeight返回视口的大小，也就是屏幕上页面可视区域的大小。
- Mobile Internet Explorer支持这些属性，但在document.documentElement.clientWidth和document.documentElement.clientHeight中提供了相同的信息。在放大或缩小页面时，这些值也会相应变化。

- 在其他移动浏览器中，document.documentElement.clientWidth和document.documentElement. clientHeight返回的布局视口的大小，即渲染页面的实际大小。布局视口是相对于可见视口的概念，可见视口只能显示整个页面的一小部分。Mobile  Internet  Explorer把布局视口的信息保存在document.body.clientWidth和document.body.clientHeight中。在放大或缩小页面时，这些值也会相应变化。

- 由于桌面浏览器的差异，所以需要先确定用户是不是在使用移动设备，然后再决定使用哪个属性。

- 使用resizeTo()和resizeBy()方法调整窗口大小。
- resizeTo(x, y) 【参数是新的宽度和高度值】
- resizeBy(x, y) 【参数是高度和宽度要是缩放多少】

```js
  window.resizeTo(100, 100)
  window.resizeBy(100, 50)
  window.resizeTo(300, 300)
```

- 与移动窗口的方法一样，缩放窗口的方法可能会被浏览器禁用，而且在某些浏览器中默认是禁用的。同样，缩放窗口的方法只能应用到最上层的window对象

#### 视口位置
- 浏览器窗口尺寸通常无法满足完整显示整个页面，为此用户为此用户可以通过滚动在有限的视口中查看文档。度量文档相对于视口滚动距离的属性有两对，返回相等的值：
  - window.pageXoffset
  - window.scrollX
  - window.pageToffset
  - window.scrollY

- 可以使用scroll()、scrollTo()、scrollBy()方法滚动页面。
- 这三个方法都接收表示相对视口距离的x和y坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。

```js
  // 相对于当前视口向下滚动100像素
  window.scrollBy(0, 100)

  // 相对于当前视口向右滚动40像素
  window.scrollBy(40, 0)

  // 滚动到页面左上角
  window.scrollTo(0, 0)

  // 滚动到距离屏幕左边及顶边各100像素的位置
  window.scrollTo(100, 100);
```

- 这几个方法也都接收一个ScrollToOptions字典，除了提供偏移值，还可以通过behavior属性告诉浏览器是否平滑滚动

```js
  // 正常滚动
  window.scrollTo({
    left: 100,
    top: 100,
    behavior: 'auto'
  })

  // 平滑滚动
  window.scrollTo({
    left: 100,
    top: 100,
    behavior: 'smooth'
  })
```

#### 导航与打开新窗口
- window.open()方法可以用于导航到指定URL，也可以用于打开新浏览器窗口。
  - 接收4个参数：
    - 要加载的URL
    - 目标窗口
    - 特性字符串
    - 表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。
  - 通常，调用这个方法时只传前三个参数，最后一个参数只有在不打开新窗口时，才会使用。

- 如果window.open()的第二个参数是一个已经存在的窗口或窗格（frame）的名字，则会在对应的窗口或窗格中打开URL。

```js
// 与<a href="http://www.wrox.com" target="topFrame"/>相同
  window.open("http://www.wrox.com/", "topFrame")
```

- 执行这行代码的结果就如同用户点击一个href属性为"http://www.wrox.com"，target属性为“topFrame”的链接。
- 如果有一个窗口名叫"topFrame"，则这个窗口就会打开这个URL；否则就会打开一个新窗口并将其命名为"topFrame"。第二个参数也可以是一个特殊的窗口名，比如_self、_parent、_top或_blank。

1. 弹出窗口
  - 如果window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页。
  - 第三个参数，即特性字符串，用于指定新窗口的配置，如果没有传则新窗口（或标签页）会带有所有默认的浏览器特性（工具栏、地址栏、状态栏等都是默认配置）
  - 如果打开的不是新窗口，则忽略第三个参数

  - 特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性。如下部分“
    - fullscreen: yes or no
    - height: Number >= 100
    - left: Number >= 0, x
    - location: yes or no; 是否显示地址栏
    - Menubar: yes or no; 是否显示菜单栏，默认为no
    - resizable: yes or no;  是否可以拖动改变新窗口大小，默认为no
    - scrollbars: yes or no; 是否可以在内容过长时滚动。默认为no
    - status: yes or no; 是否显示状态栏。不同浏览器的默认值也不一样
    - toolbar: yes or no; 是否显示工具栏，默认为no
    - top: Number >= 0; 新窗口的y轴坐标
    - width: Number >= 100;新窗口的宽度

  ```js
    window.open("http://www.wrox.com", "wroxWindow", "height=400,width=400,top=10,resizable=yes")
  ```

- window.open()方法返回一个对新建窗口的引用。这个对象与普通window对象没有区别，只是为了控制新窗口提供了方便。例如，某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过window.open()创建的窗口。跟使用任何window对象一样，可以使用这个对象操纵新打开的窗口。

```js
  let wroxWin = window.open("http://www.wrox.com/", "wroxWindow", "height=400,width=400,top=10,resizable=yes");

  // 缩放
  wroxWin.resizeTo(500, 500);
  // 引动
  wroxWin.moveTo(100, 100);

  wroxWin.close(); 
  
  alert(wroxWin.closed); // true 
```
- 可以使用close()来关闭弹出的窗口，新窗口可以调用top.close()来关闭自己
- 新创建窗口的window对象有一个属性opener，指向打开它的窗口。这个属性只在弹出窗口的最上层window对象（top）有定义，是指向调用window.open()打开它的窗口或窗格的指针。

```js
  let wroxWin = window.open("http://www.wrox.com/", "wroxWindow", "height=400,width=400,top=10,resizable=yes");

  alert(wroxWin.opener === window) // true
```

- 虽然新建窗口有指向打开他的窗口的指针，但反之则不然。
- 窗口不会跟踪记录自己打开的新窗口，需要开发者自己记录。

- 在某些浏览器中，每个标签页会运行在独立的进程中。
  - 如果一个标签页打开了另一个。而window对象需要跟另一个标签页通信，那么标签便不能运行在独立的进程中。
  - 在这些浏览器中，可以将新打开的标签页的opener属性设置为null，表示新打开的标签页可以运行在独立的进程中。比如：

  ```js
    let wroxWin = window.open("http://www.wrox.com/", "wroxWindow", "height=400,width=400,top=10,resizable=yes");
    wroxWin.opener = null;
  ```

  - 把opener设置为null表示新打开的标签页不需要与打开它的标签页通信，因此可以在独立进程中运行。这个链接一旦切断，就无法恢复了。

2. 安全限制

  - 为了限制在线广告的泛滥，浏览器开始对弹窗世家限制。
  - IE的早期版本实现针对弹窗的多重安全限制，包括不允许创建弹窗或把弹窗移出屏幕之外，以及不允许隐藏状态栏等。从IE7开始，地址栏也不能隐藏了，而且弹窗默认是不能移动或缩放的。
  - 都不会隐藏弹窗的状态栏。Firefox  3强制弹窗始终显示地址栏。Opera只会在主窗口中打开新窗口，但不允许它们出现在系统对话框的位置。
  - 浏览器会在用户操作下才允许创建弹窗。在网页加载过程中调用window.open()没有效果，而且话可能导致向用户显示错误。弹窗通常可能在鼠标点击或按下键盘中某个键的情况下才能打开。

3. 弹窗屏蔽程序
  - 所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽。在浏览器屏蔽弹窗时，可能会发生一些事。如果浏览器内置的弹窗屏蔽程序阻止了弹窗，那么window.open()很可能会返回null。此时，只要检查这个方法的返回值就可以知道弹窗是否被屏蔽了。

  ```js
    let wroxWin = window.open("http://www.wrox.com", "_blank");

    if (wroxWin == null) {
      alert("the popup was blocked！)
    }
  ```

  - 在浏览器扩展或其他程序屏蔽弹窗时，window.open()通常会抛出错误。
  - 因此要准确检测弹窗是否被屏蔽，除了检测window.open()的返回值，还要把他用try/catch包装起来，如下：

  ```js
    let blocked = false;

    try {
      let wroxWin = window.open("http://www.wrox.com", "_blank");
      if (wroxWin == null) {
        blocked = true
      }
    } catch(err) {
      blocked = true
    }

    if (blocked) {
      alert("The popup was blocked!");
    }
  ```

  - 无论弹窗是用什么方法屏蔽的，以上代码都可以准确判断调用window.open()的弹窗是否被屏蔽了.

#### 定时器
- JS在浏览器中是单线程的，但允许使用定时器指定在某个时间之后或每隔一段时间就执行相应的代码。
- setTimeout()：一定时间之后执行
- setInterval()：用于指定每隔一段时间执行某些代码

- setTimeout()方法接收两个参数：要执行的代码和在执行回调函数前等待的时间（毫秒）.
  - 第一个参数可以是包含JS代码的字符串（类似于传给eval()的字符串）或者一个函数
  - 第二个参数是要等待的毫秒数。

- JS是单线程的，所以每次只能执行一段代码。为了调度不同的执行，JS维护一个任务队列。
  - 其中的任务会按照添加到队列的先后顺序执行。
  - setTimeout()的第二个参数只是告诉JS引擎在指定的毫秒数之后把任务添加到这个队列。
  - 如果队列是空的，则会理解执行该代码
  - 如果队列不是空的，则代码必须等待前面的任务执行完才能执行。

- 调用setTimeout()时，会返回一个表示该超时排期的数值ID。
- 这个超时ID是被排期执行代码的唯一标识符，可用于取消该任务。
- 要取消等待中的排期任务，可以调用clearTimeout()，并传入超时ID

```js
  // 设置超时任务
  let timeout = setTimeout(() => alert('你好'), 1000);

  clearTimeout(timeout);
```

- 【注意】所有超时执行的代码（函数）都会在全局作用域中的一个匿名函数中运行，因此函数中的this在非严格模式下指向window；在严格模式下是undefined。
- 【注意】如果给setTimeout()提供一个箭头函数，那么this会保留为定义它时所在的词汇作用域。

- setInterval()：指定的任务会每隔指定时间就执行一次，直到取消循环定时或者页面卸载。
  - setInterval()同样可以接收两个参数：要执行的代码（字符串或函数），以及把下一次执行定时代码的任务添加到队列要等待的时间（毫秒）

```js
  setInterval(() => alert('你好十几万'), 10000)
```
