> ES6新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。
> 具体地说,可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。

### Proxy()

- 创建空代理
  - 最简单的代理就是空代理，即除了作为一个抽象的目标对象，什么也不做。
  - 默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。
  - 在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。

- new Proxy()，参数：目标对象和处理程序对象。不可缺少。

- 要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。

```js
  const target = {
    id: 'target
  };

  const handler = {};

  const proxy = new Proxy(target, handler);

  // id属性会访问同一个值
  target.id // target
  proxy.id // target

  // 给目标属性赋值会反映在两个对象上
  // 因为两个对象访问的是同一个值
  target.id = 'foo';
  target.id // foo
  proxy.id // foo

  // 给代理属性赋值会反映在两个对象上
  // 因为这个赋值会转移到目标对象
  proxy.id = 'bar';
  target.id // bar
  proxy.id // bar

  // hasOwnProperty()方法在两个地方
  // 都会应用到目标对象
  target.hasOwnProperty('id'); // true
  proxy.hasOwnProperty('id'); // true

  // Proxy.prototype是undefined
  // 因此不能使用instanceof操作符
  target instanceof Proxy // TypeError:
  proxy instanceof Proxy // TypeError

  // 严格相等可以用来区分代理和目标
  target === proxy // false
```

- 定义捕获器
  - 使用Proxy的主要目的是可以定义捕获器（trap）。
  - trap就是在处理程序对象种定义的“基本操作的拦截器”
  - 每个处理程序对象可以包含零个或多个捕获器，每个trap都对应一种基本操作，可以直接或间接在proxy上调用。
  - 每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用trap函数，从而拦截并修改相应的行为。

- trap是从操作系统中借用的概念。其意大抵是同步中断

```js
  // 定义一个get()捕获器
  const target = {
    foo: 'bar'
  };

  const handler = {
    // 捕获器在处理程序对象中以方法名为键
    get() {
      return 'handler override';
    }
  }

  const proxy = new Proxy(target, handler)

  proxy['foo'] // handler override
  proxy.foo // handler override
  Object.create(proxy)['foo'] // handler override

  /*
    get()不是ES对象可以调用的方法。这个操作在JS代码中可以通过多种形式触发并被get()捕获器拦截。
    proxy[property]、proxy.property、Object.create(proxy)[property]等操作都会触发基本的get()操作以获取属性。
    因此所有这些操作只要发生在代理对象上，就会触发get()捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。
  */
```

- 捕获器参数和反射
  - 所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。
  - 比如get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。

  ```js
    const target = {
      foo: 'bar',
      name: '李白'
    };
    const handler = {
      get (trapTarget, property, receiver) {
        console.log(trapTarget === target);
        console.log(property);
        console.log(receiver === proxy);
      }
    };
    const proxy = new Proxy(target, handler);
    proxy.foo;
    // true
    // foo
    // true
  ```

  - 有了这些参数，就可以重建被捕获方法的原始行为

  ```js
    const target = {
      foo: 'bar'
    };
    const handler = {
      get(trapTarget, property, receiver) {
        return trapTarget[property];
      }
    };

    const proxy = new Proxy(target, handler);
    proxy.foo // bar
    target.foo // bar
  ```

  - 实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局Reflect对象上（封装了原始行为）的同名方法来轻松重建。
  - 处理程序对线中所有可以捕获的方法都有对应的反射（Reflect）API方法。
    - 这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有被拦截方法相同的行为，因此使用反射API也可以向下面这样定义出空代理对象：

    ```js
      const target = {
        foo: 'bar'
      };
      const handler = {
        get() {
          return Reflect.get(...arguments);
        }
        // 更简洁
        get: Reflect.get
      };
      const proxy = new Proxy(target, handler);
      proxy.foo // bar
      target.foo // bar

    ```