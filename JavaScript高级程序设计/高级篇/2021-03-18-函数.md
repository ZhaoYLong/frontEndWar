### 参数扩展与收集
- ES6新增了扩展操作符，使用它可以简洁操作和组合集合数据。
- 扩展操作符最有用得场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。
- 扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。

#### 扩展参数

- 在给函数·传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。

```js
  let values = [1, 2, 3, 4];

  function getSum() {
    let sum = 0;
    for (let i = 0; i < arguments.length; ++i) {
      sum += arguments[i];
    }
    return sum;
  }
```

- 如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于apply()方法：
  - `console.log(getSum.apply(null, values)); // 10`

- ES6中：
  - ` getSum(...values); // 10

- 因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数:

```js
  getSum(-1, ...values); // -9
  getSum(...values, 5); // 15
  getSum(-1, ...values, 5); // 14
  getSUm(...values, ...[5, 6, 7]); // 28
```

- 对函数中的arguments对象而言，它并不知道扩展操作符的存在，而是按照调用函数时传入的参数接收每一个值。

- arguments对象只是消费操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数：

```js
  function getProduct(a, b, c = 1) {
    return a * b * c;
  }

  let getSum = (a, b, c = 0) => {
    return a + b + c;
  }

  getProduct(...[1, 2]); // 2
  getProduct(...[1,2,3]); // 6
  getProduct(...[1,2,3,4]); // 6

  getSum(...[0, 1]); // 1
  getSum(...[0, 1, 2]); // 3
  getSum(...[0, 1, 2, 3]); // 3
```

#### 收集参数

- 在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似arguments对象的构造机制。只不过收集参数的结果会得到一个Array实例。

```js
  function getSum(...values) {
    // 顺序累加values中的所有值
    // 初始值的总和为0
    return values.reduce((x, y) => x + y, 0);
  }

  getSum(1,2,3); // 6
```

- 收集参数前面如果还有命名参数，则只会收集其余的参数；
- 如果没有则会得到空数组。因为收集参数的结果是可变的，所以只能把它作为最后一个参数。

```js
  // 不可变, error
  function getP (...values, lastV) {}

  // 可变
  function ignoreF (firstV, ...values) { console.log(values)}

  ignoreF(); // []
  ignoreF(1); // []
  ignoreF(1,2,3); // [2, 3]
```

- 箭头函数不支持arguments对象，但支持收集参数的定义方式，因此也可以实现与使用arguments一样的逻辑：

```js
  let getS = (...values) => {
    return values.reduce((x,y) => x + y, 0);
  }

  getS(1,2,3); // 6

  function getSum(...values) {
    console.log(arguments.length);
    console.log(arguments);
    console.log(values);
  }

```

### 函数声明与函数表达式

- 事实上，js引擎在加载数据时对它们是区别对待的。
  - js引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。
  - 函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。

- 对于函数声明，js引擎先读取函数声明的行为，被称为函数声明提升。将函数声明提升到源码树的顶部。

- 对于函数表达式，函数定义被包裹在一个变量初始化语句中，而不是函数声明中。
  - 这意味着若代码没有执行到函数定义的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会出错。
  - 对于var和let声明的变量，函数表达式表现一样。

- 【注意】在使用函数表达式初始化变量时，也可以给函数一个名称。

### 函数作为值

- 函数名在ES中就是变量，所以函数可以在任何可以使用变量的地方。
  - 这意味着不仅可以把函数作为参数传给另一个函数
  - 而且还可以在一个函数中返回另一个函数

```js
  function callSomeFunction(someFunction, someArgument) {
    return someFunction(someArgumnet);
  }
```

- 任何函数都可以像下面这样作为参数传递：

```js
  function add10(num) {
    return num+10;
  }

  let result1 = callSomeFunction(add10, 10); // 20
```

- 如果是访问函数而不是调用函数，那就必须不带括号。【？】

- 从一个函数中返回另一个函数也是可以的，而且非常有用。例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个sort()方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。

### 函数内部

- ES5中，函数内部存在两个特殊的对象：arguments和this。
- ES6中又新增了new.target属性

- arguments是一个类数组对象，包含调用函数时传入的所有参数。
- 这个对象只有function关键字定义函数（相对于使用箭头函数语法创建函数）时才会有。
- 主要用于包含函数参数，但arguments还有一个callee属性，是一个指向arguments对象所在函数的指针。

```js
  function factorial(num) {
    if (num <= 1) {
      return 1;
    } else {
      return num * factorial(num - 1)
    }
  }
```

- 这个函数要正确执行就必须包装函数名是factorial，从而导致了紧密耦合。
  - 使用arguments。callee就可以让函数逻辑与函数名解耦：

```js
  function fa(num) {
    if (num <=0) {
      return 1;
    } else {
      return num * arguments.callee(num - 1)
    }
  }
```

- 重写之后的factorial()函数已经用arguments.callee代替之前的硬编码的factorial。这意味着无论函数叫什么名字都可以引用正确的函数。

```js
  let trueFactorial = factorial;

  factorial = function() {
    return 0;
  };

  console.log(trueFactorial(5)); // 120
  console.log(factorial(5)); // 0
```

- 上述操作相当于把同一个函数的指针又保存到了另一个位置。如果像factorial()最初的版本那样不使用arguments.callee，那么像上面这样调用trueFactorial()就会返回0。不过，通过将函数与名称解耦，trueFactorial()就可以正确计算阶乘，而factorial()则只能返回0。

- 函数中另一个特殊的对象是this，它在标准函数和箭头函数中有不同的行为。
  - 在标准函数中，this引用的是把函数当成方法调用的上下文对象，谁调用this指向谁。
  - 在箭头函数中，this引用的是定义箭头函数的上下文。即箭头函数定义在哪个上下文中，this就指向哪个上下文对象。

- 在事件回调或定时回调中调用某个函数时，this值指向的并非想要的对象，此时将回调函数写成箭头函数就可以解决问题。因为箭头函数中的this会保留定义改函数时的上下文。

```js
  function King() {
    this.royaName = "Henry"
    // this引用King的实例
    setTimeout(() => console.log(this.royaName), 1000);
  }

  function Queen() {
    this.royaName = "Elizabeth"

    // this 引用window对象
    setTimeout(function () {console.log(this.royaName)}, 1000)
  }
```

- 函数名只是保存指针的变量，因此全局定义的sayColor()函数和o.sayColor()是同一个函数，只不过执行的上下文不同。

- ES5也会给函数对象上添加一个属性：caller。虽然E3中没有定义。
  - 这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则是null。

```js
  function outer() {
    inner();
  }
  function inner() {
    console.log(inner.caller)
  }
  outer();
```

- 因为outer()调用了inner()，inner.caller指向outer()；
- 若要降低耦合度，则通过arguments.callee.caller来引用同样的值

- 严格模式下，访问arguments.callee会报错

- new.target
  - ES中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ES6新增了检测函数是否使用new关键字调用的new.target属性。
  - 如果函数可以正常调用，则new.target的值就是undefined;
  - 如果是使用new关键字调用，则new.target将引用被调用的构造函数。

```js
  function King() {
    if (!new.target) {
      throw 'King must be instantiated using"new"'
    }
    console.log('King instantiated using new')
  }

  new King();
  King();
```

### 函数属性与方法

- ES中的函数时对象，因此又属性和方法。每个函数都有两个属性：length和prototype。其中length属性保存函数定义的命名参数的个数。

- prototype属性是ES核心中最有趣的部分。
  - prototype是保存引用类型所有实例方法的地方，这意味着toString()、valueof()等方法实际上都保存在prototype上，进入由所有实例共享。
  - prototype属性在自定义类型的时候特别重要。
  - ES5中，prototype属性是不可枚举的，因此使用for-in循环不会返回这个属性

- 函数还有apply()和call()方法。这两个方法都会以指定的this值来调用函数，即会设置调用函数时函数体内this对象的值。
  - apply()方法接收两个参数：函数内this的值和一个参数数组。第二个参数可以是Array的实例，但也可以是arguments对象。

  ```js
    function sum(num1, num2) {
      return num1 + num2;
    }

    function callSum1(num1, num2) {
      return sum.apply(this, arguments); // 传入arguments对象
    }

    function callSum2(num1, num2) {
      return sum.apply(this, [num1, num2]); // 传入数组
    }

    console.log(callSum1(10, 10)); // 20
    console.log(callSum2(10, 10)); // 20
  ```

  - 在这个例子中，callSum1()会调用sum()函数，将this作为函数体内的this值（这里等于window，因为是在全局作用域中调用的）传入，同时还传入了arguments对象。callSum2()也会调用sum()函数，但会传入参数的数组。这两个函数都会执行并返回正确的结果。

- 严格模式下，调用函数时如果没有指定上下文对象，则this值不会指向window.
  - 除非使用apply()或call()把函数指定给一个对象，否则this的值变成undefined。

- call()方法与apply()的作用域一样，只是传参的形式不同。第一个参数跟apply()一样，也是this值，剩下的参数必选一一列出：

```js
  function sum (num1, num2) {
    return num1 + num2
  }

  function callSum(num1, num2) {
    return sum.call(this, num1, num2)
  }
```

- apply()和call()真正强大的地方在于控制函数调用上下文即函数体内this值得能力。

```js
  window.color = 'red';
  let o = {
    color: 'blue'
  };
  function sayColor() {
    console.log(this.color);
  }

  sayColor();

  sayColor.call(this); // red
  sayColor.call(window); // red
  sayColor.call(o); // blue
```

- 使用call()或apply()的好处就是可以将任意对象设置为任意函数的作用域，这样对象就可以不用关心方法。

- 为切换上下文需要先把sayColor()直接赋值为o的属性，然后再调用。而在这个修改后的版本中，就不需要这一步操作了。ES5出于同样的目的定义了一个新方法：bind()，bind()方法会创建一个新的函数实例，其this值会被绑定到传给bind()的对象。

- 这里，在sayColor()上调用bind()并传入对象o创建了一个新函数objectSayColor()。objectSayColor()中的this值被设置为o，因此直接调用这个函数，即使是在全局作用域中调用，也会返回字符串"blue"。

- 对函数而言，继承的方法toLocaleString()和toString()始终返回函数的代码。
  - 返回代码的具体格式因浏览器而异。
  - 有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚至代码可能被解释器修改过。
  - 由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在调试中使用它们。
- 继承的方法valueOf()返回函数本身。

### 函数表达式
- 定义函数的两种方式：
  - 函数声明
  - 函数表达式

- 函数声明的关键特点是函数声明提升，即函数声明会在代码执行前获得定义。这意味着函数声明可以出现在调用它的代码之后。

- 函数表达式有几种不同的形式，最常见的是这样：
  - `let functionName = function(arg0, arg1, arg2){//函数体}`
  - 函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量functionName。
  - 这样创建的函数叫作匿名函数（anonymous funtion），因为function关键字后面没有标识符。（匿名函数有也时候也被称为兰姆达函数）。
  - 未赋值给其他变量的匿名函数的name属性是空字符串。
  - 函数表达式不存在函数声明提升，需要先赋值再使用。

```js
  function createComparisonFunction(propertyName) {
    return function(object1, object2) {
      let value1 = object1[propertyName];
      let value2 = object2[propertyName];

      if (value1 < value2) {
        return -1;
      } else if (value1 > value2) {
        return 1;
      } else {
        return 0;
      }
    }
  }
```

### 递归与尾调优化
- 即一个函数通过名称调用自己。
- 在写递归函数的时候使用arguments.callee可以避免一些不必要的错误。
- arguments.callee就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用。
- 严格模式下不能使用arguments.callee，会报错。但可以使用命名函数表达式（named function expression）来达到同样的目的：

```js
  const factorial = (function f(num) {
    if (num <= 1) {
      return 1;
    } else {
      return num * f(num - 1)
    }
  })
```

- 这里创建了一个命名函数表达式f()，然后将他赋值给了变量factorial。即使把函数赋值给另一个变量，函数表达式的名称f也不变，因此递归调用不会有问题。在严格模式下也可以使用。

- ES6规范新增了一项内存管理优化机制，让JavaScript引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。

```js
  function outer() {
    return inner(); // 尾调用
  }
```

- ES6优化，主要是当执行内部函数的时候，外部函数所占用的栈帧会被弹出栈外。
- 这种优化是必要的，像第一种情况每多调用一次嵌套函数，就会多出一个栈帧。而第二种情况无论调用多少次嵌套函数，都只有一个栈帧。

- ES6尾调优化的关键：如果函数的逻辑允许基于尾调将其销毁，则引擎就会那样做。

- 尾调优化的条件
  - 1.代码在严格模式下执行
  - 2.外部函数的返回值是对尾调用函数的调用
  - 3.尾调用函数返回后不需要执行额外的逻辑
  - 4.尾调用函数不是尾部函数作用域中自由变量的闭包

```js
  'use strict'

  // 无优化：尾调用没有返回
  function outerFunction() { innerFunction(); } 
  // 无优化：尾调用没有直接返回
  function outerFunction() { let innerFunctionResult = innerFunction(); return innerFunctionResult; } 
  // 无优化：尾调用返回后必须转型为字符串
  function outerFunction() {   return innerFunction().toString(); } 
  // 无优化：尾调用是一个闭包
  function outerFunction() { let foo = 'bar';   function innerFunction() { return foo;}   return innerFunction(); } 

  "use strict";  
  // 有优化：栈帧销毁前执行参数计算
  function outerFunction(a, b) {   return innerFunction(a + b); } 
  // 有优化：初始返回值不涉及栈帧
  function outerFunction(a, b) { if (a < b) { return a; }   return innerFunction(a + b); } 
  // 有优化：两个内部函数都在尾部
  function outerFunction(condition) { return condition ? innerFunctionA() : innerFunctionB(); }
```