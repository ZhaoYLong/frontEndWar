> 图形和动画已经日益成为浏览器中现代化Web应用程序必备功能。
> 视觉上复杂的功能要求性能调优和硬件加速，不能拖慢浏览器。
> `<canvas>`是HTML5最受欢迎的新特性。`<canvas>`自身提供了一些API。

## 使用requestAnimationFrame

### 早期定时动画
- 在JavaScript中创建动画基本上就是使用setInterval()来控制动画的执行。

```js
    (function () {
        function updateAnimations() {
            doAnimation1();
            doAnimation2();
            // 其他任务
        }
        setInterval(updateAnimations, 100)
    })();
```

- 这种定时动画的问题在于无法准确知晓循环之间的延时。定时间隔必须足够短，这样才能让不同动画类型都能平滑顺畅。

- 使用setInterval()的定时动画比使用多个setTimeout()实现的循环效率更高，但也不是没有问题：
  - setInterval()和setTimeout()都不能保证时间精度。
  - 作为第二个参数的延时只能保证何时会把代码添加到浏览器的任务队列，不能保证添加到队列就会立即运行。如果队列前面还有其他任务，那么就要等这些任务执行完再执行。简单来讲，这里毫秒延时并不是说何时这些代码会执行，而只是说到时候会把回调加到任务队列。如果添加到队列后，主线程还被其他任务占用，比如正在处理用户操作，那么回调就不会马上执行。

### 时间间隔的问题
- 知道何时绘画下一帧是创造平滑动画的关键。
- setInterval()和setTimeout()的不精确是个大问题。
- 浏览器自身计时器的精度让这个问题雪上加霜。浏览器的计时器精度不足毫秒。
- 浏览器对切换到后台或不活跃标签中的计时器执行限流。因此即使将时间间隔设定为最优也免不了只能得到近似的结果。

### requestAnimationFrame
- 浏览器知道CSS过渡和动画应该什么时候开始，并据此计算出正确的时间间隔，到时间就去刷新用户界面。但对于JavaScript动画，浏览器不知道动画什么时候开始.
  - 创造一个mozRequestAnimationFrame()的新方法，用于通知浏览器某些js代码要执行动画了。
  - 所有浏览器都支持requestAnimationFrame()

- requestAnimationFrame()
  - 参数：要在重绘屏幕前调用的函数（这个函数就是修改DOM样式以反映下一次重绘有什么变化的地方）
  - 可以把多个requestAnimationFrame()串联起来实现动画循环，就像setTimeout()一样。

  ```js
    function updateProgress() {
        var div = document.getElementById("status");
        div.style.width = (parseInt(div.style.width, 10) + 5) + "%";
        if (div.style.left != "100%") {
            requestAnimationFrame(updateProgress);
        }
    }
    requestAnimationFrame(updateProgress);
  ```

### cancelAnimationFrame
- 与setTimeout()类似，requestAnimationFrame()也返回一个请求ID，可以用于通过另一个方法cancelAnimationFrame()来取消重绘任务

```js
    let requestID = window.requestAnimationFrame(() => {
        console.loe('Repaint');
    });
    window.cancelAnimationFrame(requestID);
```

### 通过requestAnimationFrame节流
- 支持这个方法的浏览器实际上会暴露出作为钩子的回调队列。
- 所谓钩子（hook），就是浏览器在执行下一次重绘之前的一个点。
- 这个回调队列是一个可修改的函数列表，包含应该在重绘之前调用的函数。
- 每次调用requestAnimationFrame()都会在队列上推入一个回调函数，队列的长度没有限制。

- 通过requestAnimationFrame()递归地向队列中加入回调函数，可以保证每次重绘最多只调用一次回调函数。这是一个非常好的节流工具。在频繁执行影响页面外观的代码时（比如滚动事件监听器），可以利用这个回调队列进行节流。

- 原生实现，其中的滚动事件监听器每次触发都会调用名为expensiveOperation()（耗时操作）的函数。当向下滚动网页时，这个事件很快就会被触发并执行成百上千次：

```js
    function expensiveOperation() {
        console.log('Invoke at ', Date.now());
    }

    window.addEventListener('sroll', () => {
        expensiveOperation();
    })

    // 将事件处理程序的调用限制在每次重绘前，则将它封装到requestAnimationFrame()中
    window.addEventListener('scroll', () => {
        window.requestAnimationFrame(expensiveOperation); 
    }); 
```

- 这样会把所有回调的执行集中在重绘钩子，但不会过滤掉每次重绘的多余调用。此时，定义一个标志变量，由回调设置其开关状态，就可以将多余的调用屏蔽：

```js
    let enqueued = false;

    function expensiveOperation() {
        console.log('Invoke at ', Date.now());
        enqueued = false;
    }

    window.addEventListener('scroll', () => {
        if (!enqueued) {
            enqueued = true;
            window.requestAnimationFrame(expensiveOperation);
        }
    });
```

- 因为重绘是非常频繁的操作，所以这还算不上真正的节流。
- 更好的办法是配合使用一个计时器来限制操作执行的频率。这样，计时器可以限制实际的操作执行间隔，而requestAnimationFrame控制在浏览器的哪个渲染周期中执行。
- 下面的例子可以将回调限制为不超过50毫秒执行一次:

```js
    let enabled = false;

    function expensiveOperation() {
        console.log('Invoke at ', Date.now());
    }

    window.addEventListener('scroll', () => {
        if (enabled) {
            enabled = false;
            window.requestAnimationFrame(expensiveOperation);
            window.setTimeout(() => enabled = true, 50)
        }
    });
```

## 基本的画布功能

- 创建`<canvas>`元素时至少要设置其width和height属性，这样才能告诉浏览器在多大面积上绘图。
- 出现在开始和结束标签之间的内容是后备数据，会在浏览器不支持`<canvas>`元素时显示。

```html
    <canvas id="drawing" width="200" height="200">A drawing of something</canvas>
```

- 要在画布上绘制图形，首先要取得绘图上下文。
- 使用getContext()方法可以获取对绘图上下文的引用。对于平面图形，需要给这个方法传入参数"2d"，表示要获取2D上下文对象:

```js
    let drawing = document.getElementById("drawing");

    // 确保浏览器支持<canvas>
    if (drawing.getContext) {
        let context = drawing.getContext("2d");
        // 其他code
    }
```

- 可以使用toDataURL()方法导出<canvas>元素上的图像。这个方法接收一个参数：要生成图像的MIME类型（与用来创建图形的上下文无关）。
- 例如，要从画布上导出一张PNG格式的图片，可以这样做：

```js
    let drawing = document.getElementById("drawing");

    // 确保浏览器支持
    if (drawing.getContext) {
        // 取得图像的数据URI
        let imgURI = drawing.toDataURI("image/png");

        // 显示图片
        let image = document.createElement("img");
        image.src = umgURI;
        document.body.appendChild(image);
    }
```

- 如果画布中的图像是其他域绘制过来的，toDataURL()方法就会抛出错误.

### 2D绘画上下文
- 2D绘图上下文提供了绘制2D图形的方法，包括矩形、弧形和路径。
- 2D上下文的坐标原点(0,  0)在`<canvas>`元素的左上角。
  - 所有坐标值都相对于该点计算，因此x坐标向右增长，y坐标向下增长。
  - 默认情况下，width和height表示两个方向上像素的最大值。